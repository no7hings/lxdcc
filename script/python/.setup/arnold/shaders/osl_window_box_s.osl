#include <stdosl.h>

shader osl_window_box_s(
    // x=0, -x=1, y=2, -y=3, z=4, -z=5
    int space = 0 [[ string widget = "enumerate", string options = "x|-x|y|-y|z|-z" ]],
    //
    string filename = "" [[ string widget = "filename" ]],
    int texture_flip = 0 [[ string widget = "boolean" ]],
    int texture_flop = 1 [[ string widget = "boolean" ]],
    float room_depth = 1 [[ float min = 0.1, float max = 100 ]],
    float width_overscan = 0 [[ float min = 0.0, float max = 0.9 ]],
    float height_overscan = 0 [[ float min = 0.0, float max = 0.9 ]],
    float midground_depth = 0.5 [[ float min = 0.05, float max = 99 ]],
    float midground_offset_x = 0,
    float midground_offset_y = 0,
    // modify
    vector add = 0.0,
    vector multiply = 1.0,
    //
    int curtains_enable = 1 [[ string widget = "boolean" ]],
    int midground_enable = 1 [[ string widget = "boolean" ]],
    output color out_rgb = 0.0,
)
{
    //user controls remapping
    float room_depthMult = clamp(room_depth,0.1,100);
    float height_overscanMult = 1 - clamp(height_overscan, 0, 0.9);
    float width_overscanMult = 1 - clamp(width_overscan, 0, 0.9);
    float mid_ground_depth_mult = clamp(midground_depth, 0.05, room_depthMult - 0.01);
    // 0=1, 1=-1
    float mid_ground_off_x = midground_offset_x * -(texture_flop*2-1) * 0.1;
    float mid_ground_off_y = midground_offset_y * -(texture_flip*2-1) * 0.1;
    //global variables & remapping
    // x, z, y
    vector objI = transform("object", I);
    // x
    if (space == 0){
      objI = vector(-objI[2],objI[1],objI[0])*color(width_overscanMult, height_overscanMult, 1);
    }
    // -x
    else if (space == 1){
      objI = vector(objI[2],objI[1],-objI[0])*color(width_overscanMult, height_overscanMult, 1);
    }
    // y
    else if (space == 2){
      objI = vector(-objI[0],objI[2],objI[1])*color(width_overscanMult, height_overscanMult, 1);
    }
    // -y
    else if (space == 3){
      objI = vector(-objI[0],-objI[2],-objI[1])*color(width_overscanMult, height_overscanMult, 1);
    }
    // z
    else if (space == 4){
      // -x, -y, -z
      objI = vector(objI[0],objI[1],objI[2])*color(width_overscanMult, height_overscanMult, 1);
    }
    // -z
    else if (space == 5){
      // x, -y, z
      objI = vector(-objI[0],objI[1],-objI[2])*color(width_overscanMult, height_overscanMult, 1);
    }
    else {
      objI = vector(objI[0],-objI[2],objI[1])*color(width_overscanMult, height_overscanMult, 1);
    }
    objI = vector(objI[0],objI[1],objI[2])*multiply+add;

    color objPOrig = (color(u,v,0.5)*2-1)*0.5+0.5;							//for curtains
    color objP = (color(u,v,0.5)*2-1)*color(width_overscanMult, height_overscanMult, 1) *0.5+0.5; 	//UV seems to be the better approach
    //bases for width/height/depth
    vector sections = step(0, objI);
    color baseDepth = (objP-sections)/(-objI * room_depthMult);
    color mgDepth = (objP-sections)/(-objI * mid_ground_depth_mult);
    color baseBack = (objP-sections)/(-objI);
    color baseWidth = baseDepth * room_depthMult;

    //depth and width ramps
    color baseDepthX = (baseDepth[1]*objI+objP + 1);
    color baseDepthY = (baseDepth[0]*objI+objP + 1);
    color baseWidthX = (baseWidth[1]*objI+objP + 1);
    color baseWidthY = (baseWidth[0]*objI+objP + 1);

    float horizU = baseDepthY[2] - 0.5;
    float vertU = baseWidthX[0] - 1;
    float horizV = baseWidthY[1] - 1;
    float vertV = baseDepthX[2] - 0.5;

    //convert ramps to UV/ST... WIP - not very efficient
    float sideWallsMask = step(0,horizU) * step(0,1-max(horizV, 1-horizV));
    color sideWallsUV = color(horizU, horizV, 0) / 3;
    color rWallUV = (sideWallsUV + color(2.0/3.0, 1.0/3.0, 0)) * sideWallsMask * sections[0];
    color lWallUV = (sideWallsUV + color(0.0, 1.0/3.0, 0)) * sideWallsMask * (1-sections[0]);
    lWallUV[0] = (1.0/3.0 - lWallUV[0]) * sideWallsMask * (1-sections[0]);

    float FloorCeilMask = step(0,vertV) * step(0,1-max(vertU, 1-vertU));
    color FloorCeilUV = color(vertU, vertV, 0) / 3;
    color ceilUV = (FloorCeilUV + color(1.0/3.0, 2.0/3.0, 0)) * FloorCeilMask * sections[1];
    color floorUV = (FloorCeilUV + color(1.0/3.0, 0, 0)) * FloorCeilMask * (1-sections[1]);
    floorUV[1] = (1.0/3.0 - floorUV[1]) * FloorCeilMask * (1-sections[1]);

    color backWallUV = ((baseBack[2]*objI + (objP/2)/(room_depthMult)) * (room_depthMult*2) / 3 + color(1.0/3.0, 1.0/3.0, 0) ) * (1 - max(step(0,horizU), step(0,vertV)));

    color mid_ground_uv = (1.0/3.0 - (baseBack[2]*objI + (objP)/(mid_ground_depth_mult*2)) * (mid_ground_depth_mult*2) / 3);
    float mid_ground_mask = step( 0, mid_ground_uv[1] * 3 * (1-mid_ground_uv[1]*3) ) * step( 0, mid_ground_uv[0] * (1.0/3.0-mid_ground_uv[0]) );
    mid_ground_uv = (color(mid_ground_off_x, mid_ground_off_y, 0) + mid_ground_uv) * mid_ground_mask;
    mid_ground_uv[1] = 1-mid_ground_uv[1];

    color curtains_uv = objPOrig * color(1.0/3.0, 1.0/3.0, 1);
    curtains_uv[0] = curtains_uv[0];

    color finalUV = ceilUV + floorUV + rWallUV + lWallUV + backWallUV;

    // flip
    if (texture_flip > 0){
        mid_ground_uv[1] = 1 - mid_ground_uv[1] + 2.0/3.0;
        curtains_uv[1] = - curtains_uv[1] + 1.0/3.0;
    }else
        finalUV[1] = 1-finalUV[1];
        mid_ground_uv[1] = 1 - mid_ground_uv[1];
        curtains_uv[1] = 1 - curtains_uv[1];

    // flop
    if (texture_flop > 0){
        finalUV[0] = 1-finalUV[0];
        mid_ground_uv[0] = mid_ground_uv[0];
        curtains_uv[0] = - curtains_uv[0] + 1.0/3.0;
    }else
        mid_ground_uv[0] = 1.0/3.0 - mid_ground_uv[0];
        curtains_uv[0] = curtains_uv[0];

    color room_rgb = texture(filename, finalUV[0], finalUV[1]);

    color final_rgb;

    //mid ground switch
    if (midground_enable > 0){
        float mid_ground_a;
        color mid_ground_rgb = texture(filename, mid_ground_uv[0], mid_ground_uv[1], "alpha", mid_ground_a);
        final_rgb = mix(room_rgb, mid_ground_rgb, mid_ground_a);
    }
    else{
        final_rgb = room_rgb;
    }

    //curtains switch
    if (curtains_enable > 0){
        float curtains_a;
        color curtains_rgb = texture(filename, curtains_uv[0], curtains_uv[1], "alpha", curtains_a);
        final_rgb = mix(final_rgb, curtains_rgb, curtains_a);
    }

    out_rgb = final_rgb;

}